<link rel="stylesheet" href="./css/reset.css">
<a class="forkme" href="https://yanokunpei.github.io/introduction_of_Rust">Fork me on GitHub</a>
# 参照と借用
## 借用
もし関数で所有権を返さなければならないのであれば、こうなります。
```Rust
fn foo(v: Vec<i32>) -> Vec<i32> {
    // vについての作業を行う
    v // 所有権を返す
}
```
これは非常に面倒です。  
もっとたくさんの所有権を受け取れば、更に面倒になります。
```Rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // v1とv2についての作業を行う
    (v1, v2, 42) // 所有権と関数の結果を返す
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

とても面倒です。  
これを解決するために次に借用という機能を説明します。
```Rust
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // v1とv2についての作業を行う
    12// 答えを返す
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);
println!(v1[0]) // 1
```
引数として`Vec<i32>`を取るのではなくではなく、参照 `&Vec<i32>` を使います。`v1`と`v2`を直接渡さず、`&v1`と`&v2`を渡します。`&T 型`は「参照」と呼ばれ、それは、リソースを所有するのではなく、所有権を借用します。借用した変数はスコープから外れるときにリソースを開放するのではなく所有権を返却します。それにより`foo()`の呼出し後に元の変数を再び使えます。

参照はイミュータブルです。`foo()`の中ではベクタを変更できません。

```Rust
fn foo(v: &Vec<i32>) {
     v.push(5); // コンパイルエラー
}
let v = vec![];

foo(&v);
```

## &mut参照

参照には`&mut T`という「ミュータブルな参照」もあります
```Rust
fn main() {
  let mut x: i32 = 5;
	{
    let y = &mut x;
    println!("{}", y);  // 5: &mut i32
    println!("{}", *y); // 5: i32
    *y += 1;
    // y += 1;  これはコンパイルエラー
	}
  println!("{}", x); // 6: i32
}
```
`x`は ミュータブルである必要があります。 イミュータブルな値へのミュータブルな借用はできません。
&mut参照には前に`*`をつける必要があります。参照の内容にアクセスするためにも`*`をつける必要があります。

以下例外
```Rust
fn main() {
  let mut x: Vec<i32> = vec![0,1,2];
	{
    let y = &mut x;
    println!("{}", y[0]); // 0
    // println!("{}", *y[0]); コンパイルエラー
    y[0] += 1;
    // *y[0] += 1;　コンパイルエラー
	}
	println!("{}", x[0]); // 1
}
```
## ルール
Rustの借用のルールです。
+ 借用は所有者のスコープより長く存続してはならない。
+ `&mut T`と`&mut T`の両方を同時に作れない。
+ `&mut T`は複数作れない。

「データ競合」は2つ以上のポインタがメモリの同じ場所に同時にアクセスし、1つ以上が書込みを行っていて、作業が同期されていない時に起きます。
書込まなければ、参照はいくらでも使うことができます。

## スコープ
このコードについて考えていきます。
```Rust
fn main() {
  let mut x = 5;
  let y = &mut x;     // -+　&mut借用開始
  *y += 1;            //  |
  println!("{}", x);  //  |-ここでイミュータブルな借用→コンパイルエラー
}                     // -+ &mut借用終了
```
ミュータブルな借用はスコープが切れるまで保持されます。
ブロックを追加してみましょう。

```Rust
let mut x = 5;
{
    let y = &mut x; // -+ &mut借用開始
    *y += 1;        //  |
}                   // -+ &mut借用終了

println!("{}", x);  // <- ここでイミュータブルな借用
```
コンパイルが通ります。
