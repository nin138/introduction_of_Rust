# ライフタイム
借用は複雑になることがあります。次のような一連の作業を想像しましょう。

1. `A`がリソースへのハンドルを取得する
2. `A`が`B`にリソースへの参照を貸し付ける
3. `A`がリソースを使い終わり、解放するが`B`は参照をまだ持っている
4. `B`がリソースを使う

`B`の参照は無効なリソースを指示しています。 リソースがメモリであるとき、これはダングリングポインタ又は「解放後の使用」と呼ばれます。

これを修正するためには、ステップ3の後にステップ4が絶対に起こらないようにしなければなりません。  
```Rust
fn skip_prefix(line: &str, prefix: &str) -> &str {
    // ...
}

let line = "lang:en=Hello World!";
let lang = "en";

let v;
{
    let p = format!("lang:{}=", lang);  // -+ `p` がスコープに入る。
    v = skip_prefix(line, p.as_str());  //  |
}                                       // -+ `p` がスコープから外れる。
println!("{}", v);
```
上記の例ではパラメータとして2つの`＆str参照`を取り、1つの＆str参照を返す関数`skip_prefix`があります。  
`skip_prefix`を`line`と`p`の参照を渡し呼びます(ライフタイムが異なる2つの変数)。
`println`の行の安全性は、skip_prefix関数によって返された参照がまだ生きているか、既にドロップされた`p`を参照するかどうかによって決まります。

上記の曖昧さのため、Rustは上記のコードのコンパイルを拒否します。コンパイルするには、コンパイラに参照の存続期間を伝えるために、関数宣言で明示的に`ライフタイム`を与える必要があります。
```Rust
fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {
    // ...
}
```

---
`ライフタイム`とは参照の有効なスコープを記述するものです。引数として参照を受け取る関数で、参照のライフタイムを示すことができます。
```Rust
// 黙示的に
fn foo(x: &i32) {
}
// 明示的に
fn bar<'a>(x: &'a i32) {
}
```
`'a`は`ライフタイムa`と読みます。　　
技術的には参照は全てそれに関連するライフタイムを持ちますが、一般的な場合には省略可能です。
```Rust
fn bar<'a>(...)
```
関数名の後の `<>` の間に`「ジェネリックパラメータ」`を持つことができ、ライフタイムはその一種です。  
`<'a>`は`bar`がライフタイム`'a`を持つことを意味します。 もし2つの参照引数がある場合以下のように書けます。
```Rust
fn bar<'a, 'b>(...)
```
そして引数リストでは、名付けたライフタイムを使います。

...(x: &'a i32)
もし &mut 参照が欲しいのならば、次のようにします。

...(x: &'a mut i32)
もし &mut i32 を &'a mut i32 と比較するならば、それらは同じです。それはライフタイム 'a が & と mut i32 の間にこっそり入っているだけです。 &mut i32 は「 i32 へのミュータブルな参照」のように読み、 &'a mut i32 は「ライフタイム 'a を持つ i32 へのミュータブルな参照」のように読みます。

struct の中

参照を含む struct を使うときにも、明示的なライフタイムを必要とするでしょう。

struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ
    let f = Foo { x: y };

    println!("{}", f.x);
}
見てのとおり、 struct もライフタイムを持つことができます。 これは関数と同じ方法です。

struct Foo<'a> {
このようにライフタイムを宣言します。

x: &'a i32,
そしてそれを使います。 それではなぜここでライフタイムを必要とするのでしょうか。 Foo への全ての参照がそれの含む i32 への参照より長い間有効にはならないことを保証する必要があるからです。

impl ブロック
Foo に次のようなメソッドを実装しましょう。

struct Foo<'a> {
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> &'a i32 { self.x }
}

fn main() {
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ
    let f = Foo { x: y };

    println!("x is: {}", f.x());
}
見てのとおり、 Foo のライフタイムは impl 行で宣言する必要があります。 ちょうど関数のときのように 'a は2回繰り返されます。つまり、 impl<'a> はライフタイム 'a を定義し、 Foo<'a> はそれを使うのです。

複数のライフタイム
もし複数の参照があれば、同じライフタイムを複数回使うことができます。

fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
これは x と y が両方とも同じスコープで有効であり、戻り値もそのスコープで有効であることを示します。 もし x と y に違うライフタイムを持たせたいのであれば、複数のライフタイムパラメータを使うことができます。

fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
この例では x と y が異なる有効なスコープを持ちますが、戻り値は x と同じライフタイムを持ちます。

スコープの考え方
ライフタイムについて考えるには、参照の有効なスコープを可視化することです。 例えばこうです。

fn main() {
    let y = &5;     // -+ yがスコープに入る
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ yがスコープから出る
Foo を追加するとこうなります。

struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;           // -+ yがスコープに入る
    let f = Foo { x: y }; // -+ fがスコープに入る
    // stuff              //  |
                          //  |
}                         // -+ fとyがスコープから出る
f は y のスコープの中で有効なので、全て動きます。 もしそれがそうではなかったらどうでしょうか。 このコードは動かないでしょう。

struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ xがスコープに入る
                              //  |
    {                         //  |
        let y = &5;           // ---+ yがスコープに入る
        let f = Foo { x: y }; // ---+ fがスコープに入る
        x = &f.x;             //  | | ここでエラーが起きる
    }                         // ---+ fとyがスコープから出る
                              //  |
    println!("{}", x);        //  |
}                             // -+ xがスコープから出る
ふう! 見てのとおり、ここでは f と y のスコープは x のスコープよりも小さいです。 しかし x = &f.x を実行するとき、 x をまさにスコープから外れた何かの参照にしてしまいます。

名前の付いたライフタイムはそれらのスコープに名前を与える方法です。 何かに名前を与えることはそれについて話をすることができるようになるための最初のステップです。

'static
「static」と名付けられたライフタイムは特別なライフタイムです。 それは何かがプログラム全体に渡るライフタイムを持つことを示します。 ほとんどのRustのプログラマが最初に 'static に出会うのは、文字列を扱うときです。

let x: &'static str = "Hello, world.";
文字列リテラルは &'static str 型を持ちます。なぜなら、参照が常に有効だからです。それらは最終的なバイナリのデータセグメントに焼き付けられます。 もう1つの例はグローバルです。

static FOO: i32 = 5;
let x: &'static i32 = &FOO;
これはバイナリのデータセグメントに i32 を追加します。そして、 x はそれへの参照です。

ライフタイムの省略
Rustは関数本体の部分では強力なローカル型推論をサポートします。しかし要素のシグネチャの部分では、型が要素のシグネチャだけでわかるようにするため、（型推論が）許されていません。 とはいえ、エルゴノミック（人間にとっての扱いやすさ）の理由により、"ライフタイムの省略"と呼ばれている、非常に制限された第二の推論アルゴリズムがシグネチャの部分に適用されます。 その推論はシグネチャのコンポーネントだけに基づき、関数本体には基づかず、ライフタイムパラメータだけを推論します。そしてたった3つの覚えやすく明確なルールに従って行います。 ライフタイムの省略で要素のシグネチャを短く書くことができます。しかしローカル型推論が適用されるときのように実際の型を隠すことはできません。

ライフタイムの省略について話すときには、 入力ライフタイム と 出力ライフタイム という用語を使います。 入力ライフタイム は関数の引数に関連するライフタイムで、 出力ライフタイム は関数の戻り値に関連するライフタイムです。 例えば、次の関数は入力ライフタイムを持ちます。

fn foo<'a>(bar: &'a str)
この関数は出力ライフタイムを持ちます。

fn foo<'a>() -> &'a str
この関数は両方の位置のライフタイムを持ちます。

fn foo<'a>(bar: &'a str) -> &'a str
これが3つのルールです。

関数の引数の中の省略された各ライフタイムは互いに異なるライフタイムパラメータになる
もし入力ライフタイムが1つだけならば、省略されたかどうかにかかわらず、そのライフタイムはその関数の戻り値の中の省略されたライフタイム全てに割り当てられる
もし入力ライフタイムが複数あるが、その1つが &self 又は &mut self であれば、 self のライフタイムは省略された出力ライフタイム全てに割り当てられる
そうでないときは、出力ライフタイムの省略はエラーです。

例

ここにライフタイムの省略された関数の例を示します。 省略されたライフタイムの各例をその展開した形式と組み合わせています。

fn print(s: &str); // 省略された形
fn print<'a>(s: &'a str); // 展開した形

fn debug(lvl: u32, s: &str); // 省略された形
fn debug<'a>(lvl: u32, s: &'a str); // 展開された形

// 前述の例では`lvl`はライフタイムを必要としません。なぜなら、それは参照（`&`）
// ではないからです。（参照を含む`struct`のような）参照に関係するものだけがライ
// フタイムを必要とします。

fn substr(s: &str, until: u32) -> &str; // 省略された形
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // 展開された形

fn get_str() -> &str; // 不正。入力がない

fn frob(s: &str, t: &str) -> &str; // 不正。入力が2つある
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // 展開された形。出力ライフタイムが決まらない

fn get_mut(&mut self) -> &mut T; // 省略された形
fn get_mut<'a>(&'a mut self) -> &'a mut T; // 展開された形

fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command; // 省略された形
fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // 展開された形

fn new(buf: &mut [u8]) -> BufWriter; // 省略された形
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // 展開された形
