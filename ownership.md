# 所有権
## 概要
Rustの特徴であり、Rustの最大の目標、メモリ安全性を得るための方法です。

Rustは「ゼロコスト抽象化」を通じて安全性とスピードという目標を達成しています。「ゼロコスト抽象化」とは抽象化を機能させるためのコストをできる限り小さくすることを意味します。 所有権システムはゼロコスト抽象化の主な例で、解析の全ては コンパイル時に行われるためどの機能に対しても実行時のコストは全く掛かりません。
ただし学習コストは高く慣れるまでなかなかコンパイルが通らないそうです。
## 所有権
Rustでは変数は所有権を持ち変数がスコープから外れるとき、Rustはリソースを解放します。
```Rust
fn hoge() {
    let v = vec![1, 2, 3];
}
```
`v`がスコープに入るとき、新しい Vec<T> が作られ、ヒープに空間を割り当てます。`hoge()` の終了時 `v` がスコープから外れるとき、Rustはベクタに関連するもの__全て__を取り除きます。それがヒープ割当てのメモリであってもです。

## ムーブセマンティクス

Rustでは与えられたリソースに対する変数が 1つだけ です。
```Rust
let v = vec![1, 2, 3];
let v2 = v;
println!("{}", v[0]); // コンパイルエラー "use of moved value: `v`"
```
所有権を受け取る関数を定義して、引数として渡した場合でも同じようなことが起きます。
```Rust
fn take(v: Vec<i32>) {
    // ここで何が起きるかは重要ではない
}
let v = vec![1, 2, 3];
take(v);
println!("{}", v[0]); // 同じコンパイルエラー
```
所有権を何か別のものに転送するとき、参照するものを「ムーブした」と言います。

変数をムーブした後で使うことができない理由を説明します。
```Rust
let v = vec![1, 2, 3];
let v2 = v;
```
最初の行はベクタオブジェクト`v`とそれの含むデータにメモリを割り当てます。 ベクタオブジェクトは スタック に保存され、ヒープに保存された内容`[1, 2, 3]`へのポインタを持ちます。  
`v`を`v2`にムーブすると、`v2`にベクタオブジェクトのコピーを割り当てます。このシャローコピーは、実際のデータを含むヒープ割り当てのコピーを作成しません 。それは、ヒープ上のベクタの内容へのポインタが2つあることを意味し、データ競合を引き起こしかねないためRustの安全性保証に違反します。そのため、Rustはムーブを終えた後の`v`の使用を禁止します。


たとえば、ベクトルをv2から2つの要素に切り捨てた場合、
```Rust
v2.truncate（2）; // 引数以降のインデックスの要素を削除する
```
もし`v`がまだアクセス可能だった場合ヒープデータが切り捨てられていることがわからないため、スタック上のベクトルvの部分は、ヒープ上の対応する部分と一致しません。 vはまだベクトルに3つの要素があると思っていて、実際には存在しない要素`v[2]`にアクセスする可能性があります、これはセグメンテーションフォルトにつながるか、権限のないユーザーがアクセスできないメモリから読み取ることができるといった不具合につながります。
そのため、Rustはムーブを終えた後の`v`の使用を禁止します。

## Copy型

所有権が別の変数に転送されると、元の変数は使用できません。しかし、この振る舞いを変える`コピー`という`トレイト`があります。トレイトについては後ほど説明しますが今のところは特別な動作を追加する特定のタイプの注釈と考えておきましょう。
```Rust
let v = 1;
let v2 = v;
println!("{}", v);
```
この場合、`v`は`i32`で、`i32`はコピートレイトをインプリメントしています。vをv2に代入すると、データのコピーが作成されます。これは、移動とは異なり、vはその後も使用できます。これは、i32はデータへのポインタではないため、完全なコピーだからです。  
すべてのプリミティブ型はコピー特性を実装しているため、所有権ルールにしたがって所有権が引き継がれるわけではありません。
```Rust
fn main() {
    let x = 3;
    let y = x;
    println!("{}", x); // 3
}
```
