# 関数

Rustの関数は`fn`で定義します。
```Rust
fn 関数名() {

}
```
 引数を取る場合
 ```Rust
fn print_number(x: i32) {
    println!("{}", x);
}
```
let と異なり、引数には型アノテーションが必要です。

戻り値がある場合
```Rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```
Rustの関数は1つだけ値を返します。`->`の後戻り値の型を宣言します。  最後の`式`が戻り値になります。  
最後にセミコロンがないことに気が付くでしょう。 もしそれを追加すると、こうなります。
```Rust
fn add_one(x: i32) -> i32 {
    x + 1;
}
```
エラーが発生します。  
`x + 1;`は式ではなく式文だからです。  
この関数は i32 を返そうとしていますが、セミコロンを付ければ代わりに () を返します。 Rustはこの挙動が求めているものではないと判断し、セミコロンを削除することを提案します。

---
## 式と文
Rustは主として式ベースの言語です。 文には2種類しかなく、その他の全ては式です。

式は値を返しますが、文は返しません。  
Rustには2種類しか文はありません。「宣言文」と「式文」です。 その他の全ては式です。

### 宣言文
```Rust
let x = 1;
```
変数を宣言する`let`をつかったものが宣言文です。
let は式ではなく文の先頭にしかなりません。

ただし、既に束縛されている変数への割当て
```Rust
x =2;
```
は、式です。ただし割当てRustでは割当ての値は空のタプル () です。なぜなら、割り当てられる値には 単一の所有者 しかおらず、他のどんな値を返したとしても予想外の出来事になってしまうからです。

```Rust
let mut y = 1;
let x = (y = 2);  // xの値は`2`ではなく `()` です！
```


### 式文
Rustの文法では文の後には他の文が続くことが期待されています。 式文はそれぞれの式を区切るために`;`を式の終わりにつけたものです。

---  

## ダイバージング関数
Rustはリターンしない関数、「ダイバージング関数」のための特別な構文をいくつか持っています。
```Rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```
`panic!` マクロは実行中の現在のスレッドを与えられたメッセージとともにクラッシュさせます。 この関数はクラッシュを引き起こすので、決してリターンしません。そのため、それは「ダイバージ」と読む、`!`型を持つのです。

もし diverges() を呼び出すメイン関数を追加してそれを実行さたら、以下のメッセージが出力さます。
```
thread ‘<main>’ panicked at ‘This function never returns!’, hello.rs:2
```
もしもっと情報を得たいと思うのであれば、 `RUST_BACKTRACE` 環境変数をセットすることでバックトレースを得ることができます。
```
$ RUST_BACKTRACE=1 ./diverges
```
RUST_BACKTRACE はCargoの run コマンドでも使うことができます。
```
$ RUST_BACKTRACE=1 cargo run
```

ダイバージング関数は任意の型として使うことができます。
```Rust
let x: i32 = diverges();
let x: String = diverges();
```
## 関数ポインタ
関数を指示する変数を作ることもできます。
```Rust
let f: fn(i32) -> i32;
```
f は i32 を引数として受け取り、 i32 を返す関数を指示する変数です。
```Rust
fn plus_one(i: i32) -> i32 {
    i + 1
}
let f: fn(i32) -> i32 = plus_one;
//　let文では型を書く必要はありませんね
let f = plus_one;Run

let x = f(2);
println!("{}", x); // 3;
```
