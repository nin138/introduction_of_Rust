# 関数

Rustの関数は`fn`で定義します。
```Rust
fn 関数名() {
}
```
 引数を取る場合
 ```Rust
fn print_number(x: i32) {
    println!("{}", x);
}
```
let と異なり、引数には型アノテーションが必要です。

戻り値がある場合
```Rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```
Rustの関数は1つだけ値を返します。`->`の後戻り値の型を宣言します。  最後の`式`が戻り値になります。  
最後にセミコロンをつけると式でなく`式文`になります。
```Rust
fn add_one(x: i32) -> i32 {
    x + 1;
}
```
エラーが発生します。  
`x + 1;`は式ではなく式文だからです。  
この関数の戻り値の型は`i32`ですが、式文は`()`を返します。

---
## 式と文
Rustは主として式ベースの言語です。 文には2種類しかなく、その他の全ては式です。
式は値を返しますが、文は返しません。  
Rustには2種類しか文はありません。「宣言文」と「式文」です。 その他の全ては式です。

### 宣言文
```Rust
let x = 1;
```
変数を宣言する`let`をつかったものが宣言文です。
let は式ではなく文の先頭にしかなりません。
ただし、変数への値の代入は式です。
```Rust
x = 2;
```
ただしRust代入は常に`()`です。値には単一の所有者しかいないからです。詳しくは所有権を参照のこと。

```Rust
let mut y = 1;
let x = (y = 2);  // xの値は`2`ではなく `()` です！
```
### 式文
Rustの文法では文の後には他の文が続くことが期待されています。 式文はそれぞれの式を区切るために`;`を式の終わりにつけたものです。

---  
## 関数ポインタ
関数を指示する変数を作ることもできます。
```Rust
let f: fn(i32) -> i32;
```
f は i32 を引数として受け取り、 i32 を返す関数を指示する変数です。
```Rust
fn plus_one(i: i32) -> i32 {
    i + 1
}
let f: fn(i32) -> i32 = plus_one;
//　let文では型を書く必要はありませんね
let f = plus_one;

let x = f(2);
println!("{}", x); // 3;
```
---

## ダイバージング関数
Rustはリターンしない関数、「ダイバージング関数」のための特別な構文をいくつか持っています。
```Rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```
`panic!` マクロは実行中の現在のスレッドを与えられたメッセージとともにクラッシュさせます。 この関数はクラッシュを引き起こすので、決してリターンしません。そのため、それは「ダイバージ」と読む、`!`型を持つのです。

もし diverges() を呼び出すメイン関数を追加してそれを実行さたら、以下のメッセージが出力さます。
```
thread ‘<main>’ panicked at ‘This function never returns!’, hello.rs:2
```
もしもっと情報を得たいと思うのであれば、 `RUST_BACKTRACE` 環境変数をセットすることでバックトレースを得ることができます。
```
$ RUST_BACKTRACE=1 ./diverges
```
RUST_BACKTRACE はCargoの run コマンドでも使うことができます。
```
$ RUST_BACKTRACE=1 cargo run
```

ダイバージング関数は任意の型として使うことができます。
```Rust
let x: i32 = diverges();
let x: String = diverges();
```
